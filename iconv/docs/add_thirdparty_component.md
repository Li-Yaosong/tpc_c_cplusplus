# 如何添加一个三方库到三方库子系统中

## 简介

OpenHarmony整体遵从分层设计，从下向上依次为：内核层、系统服务层、框架层和应用层。系统功能按照“系统 > 子系统 > 组件”逐级展开，在多设备部署场景下，支持根据实际需求裁剪某些非必要的组件。

### 什么是子系统


子系统是一个逻辑概念，它具体由对应的组件构成。

### 什么是组件

组件是对子系统的进一步拆分，可复用的软件单元，它包含源码、配置文件、资源文件和编译脚本；能独立构建，以二进制方式集成，具备独立验证能力的二进制单元。

### 三方库子系统

三方库子系统就是由三方库组件组成的，它包含三方库源码，配置文件、资源文件和编译脚本且能独立编译构建。

## 三方库子系统添加三方库步骤

适配完一个三方库后，为了方便管理，也是为了尽量少修改系统源码，我们需要将三方库添加到三方库子系统中，通过三方库子系统将我们的三方库添加到系统的编译构建体系中。在此以libiconv适配到OpeHarmony3.2 beta1上编译并最终使用到RK356开发中为例：

### 定义三方库组件

在三方库目录下新建ohos.build文件，并创建三方库组件名

```
{
	"subsystem": "thirdparty",				# 三方库子系统名
    "parts":{
      "iconv": {							# 三方库的iconv组件名
        "module_list": [
          "//third_party/iconv:libiconv"	# 三方库路径以及目标
        ]
      }
    }
}
```

理论上ohos.build文件可以放在子系统目录的任意路径下，编译构建系统会在子系统目录下搜索所有的ohos.build文件并查找对应的组件名。

### 在三方库子系统中添加组件

三方库子系统定义在//vendor/hihope/rk356/config.json文件中，我们打开此文件并找到thirdparty子系统，在该子系统下添加新定义的组件(上面步骤定义的iconv组件)：

```
...
{
      "subsystem": "thirdparty",		# 三方库子系统名
      "components": [					# 组件定义开始
        {								# musl组件
          "component": "musl",
          "features": []
        },
        {								# 新增iconv组件
          "component": "iconv",
          "features": []
        }
      ]									# 组件定义结束
},
...
```

添加完组件后，编译构建系统会在子系统的目录下查找所有ohos.build文件，并匹配对应的组件名，匹配到相应的组件名后便将该组件定义的module_list列表添加到编译构建中进行编译。

### 三方库中引入组件名

三方库适配完后，也定义了对应的组件，但如果三方库中不引入对应的组件名，编译构建系统可以编译该三方库，但最后不会将三方库打包拷贝到系统固件中，因此我们还需要在三方库的适配脚本中添加对应的组件名：

```
ohos_shared_library("iconv"){		## 三方库名
    ...								## 三方库适配内容(已省略) 
    part_name = "iconv"				## 组件统名
}
```



至此，我们就将libiconv添加到了三方库子系统中，并通过系统编译指令(hb build)编译后，在//out/rk3568/packages/phone/system/lib/下可以查看到我们生成的libiconv.z.so文件。

## 参考资料

- [OpenHarmony三方库组织地址](https://gitee.com/openharmony-tpc)。 
- [知识体系](https://gitee.com/openharmony-sig/knowledge)。